<%@ page contentType="text/html; charset=utf-8" language="java" import="java.sql.*" errorPage="" %>

<%@ page import="java.util.*"%>

<html>
<%
Collection coll=(Collection)request.getAttribute("managerQuery");
%>
<head>
<title>知识点系统</title>
<link href="CSS/style.css" rel="stylesheet">
</head>
<body onLoad="clockon(bgclock)">
<%@include file="banner.jsp"%>
	<%@include file="navigation.jsp"%>
	<table width="778"  border="0" cellspacing="0" cellpadding="0" align="center">
  <tr>
    <td valign="top" bgcolor="#FFFFFF"><table width="99%" height="510"  border="0" align="center" cellpadding="0" cellspacing="0" bgcolor="#FFFFFF" class="tableBorder_gray">

一、查找<br/>
查找表<br/>
（1）一种以集合为逻辑结构，以查找为“核心”运算，同时包括其它运算的数据结构；<br/>
（2）由同一类型的数据元素构成的集合；<br/>
（3）查找表分为静态查找表和动态查找表。<br/>
 静态查找表<br/>
只对查找表进行查询某个特定的数据元素或某个特定数据元素的各种属性的操作。<br/>
动态查找表<br/>
对查找表进行插入或删除某个数据元素的操作。<br/>
 查找的定义<br/>
根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素。<br/>
关键字（Key）<br/>
（1）数据元素中某个数据项的值；<br/>
（2）当数据元素中只有一个数据项时，其关键字就是该数据元素的值。<br/>
 主关键字<br/>
可以唯一标识一个记录的关键字。<br/>
衡量查找算法的标准<br/>
（1）平均查找长度；<br/>
（2）算法所需要的存储量和算法的复杂性等。<br/>
 平均查找长度（ASL—Average Search Length）<br/>
（1）为确定记录在表中的位置所进行的和关键字比较的次数的期望值；<br/>
（2）衡量一个查找算法好坏的依据。<br/>
 <img src ="Images/look1.jpg" /> </br>
n：查找表的长度<br/>
：查找第i个元素的概率<br/>
：查找第i个元素时同给定值K比较的次数<br/>
二、 顺序查找算法<br/>
顺序查找方法是用待查关键码Key依次和查找表中元素的关键码进行比较，若找到相等的，就称为查找成功，假设把整个查找表找完都没有找到和给定关键码相等的元素，<br/>
则称为查找失败。<br/>
存储方式方法的实现<br/>
get（L，i）//L是顺序表<br/>
get（L，i）//L是单链表<br/>
两个操作实现的步骤是完全一样的<br/>
 顺序表的表示<br/>
typedef struct{<br/>
Elem Type  * R;   //表基址<br/>
int length； // 表长<br/>
}SSTable；<br/>
 Elem Type的定义<br/>
typedef struct{<br/>
KeyType  Key;   //关键字<br/>
infotype otherinfo；<br/>
}Elem Type；<br/>
typedef struct{<br/>
ElemType * R ；//表基址<br/>
int length；//表长<br/>
} SSTable；<br/>
 <img src ="Images/look2.jpg" /> </br>
查找方式<br/>
 从前往后进行查找<br/>
 <img src ="Images/look3.jpg" /> </br>
 从后往前进行查找<br/>
 <img src ="Images/look4.jpg" /> </br>
 监视哨<br/>
 <img src ="Images/look5.jpg" /> </br>
三、 顺序查找算法时间复杂度分析<br/>
顺序查找的特点<br/>
（1）算法简单，对查找表的结点之间没有排序要求，对表的存储结构也无任何要求（顺序和链式）<br/>
（2）n很大时查找效率较低，与n成反比，平均约为n/2<br/>
（3）改进措施：非等概率查找时，可按照查找概率进行排序<br/><br/>
 <img src ="Images/look6.jpg" /> </br>
四、 折半查找的基本思想<br/>
字典的特点<br/>
（1）按关键字有序排列；<br/>
（2）按顺序方式存储<br/>
折半查找的要求<br/>
（1）查找表中结点必须按关键字有序排列；<br/>
（2）查找表必须顺序存储。<br/>
 折半查找的方法<br/>
用待查关键字k与线性表中间位置的结点的关键字进行比较：<br/>
（1）若相等，则查找成功；<br/>
（2）若不相等，则根据比较的结果确定下一步操作：<br/>
若k小于中间结点的关键字，则对前半个子表进行查找；<br/>
若k大于中间结点的关键字，则对后半个子表进行查找；<br/>
若整张表都没有找到满足条件的结点，则查找失败。<br/>
 <img src ="Images/look7.jpg" /> </br>
  <img src ="Images/look8.jpg" /> </br>
   <img src ="Images/look9.jpg" /> </br>

五、 折半查找算法的描述<br/><br/>
   <img src ="Images/look10.jpg" /> </br>
   <img src ="Images/look11.jpg" /> </br>
六、 折半查找算法的时间复杂度<br/><br/>
   <img src ="Images/look12.jpg" /> </br>
      <img src ="Images/look13.jpg" /> </br>
折半查找的性能分析：<br/>
查找成功：每次将待查找记录所在区间缩小一半，比顺序查找效率高。<br/>
使用条件：采用顺序存储结构的有序表，不适用于链式结构。<br/>
七、 二叉排序树的定义<br/>
 动态查找的思想<br/>
表结构在查找过程中动态生成，对于给定值key：<br/>
若表中存在，则成功返回；否则插入关键字等于key的记录<br/>
折半查找效率好的原因<br/>
把查找表中的数据事先进行了有效的组织，把它有序化，这样给定n个数，可以形成一个叫做判定树的结构。<br/>
二叉排序树的定义<br/>
二叉排序树或是空树，或是满足如下性质的二叉树：<br/>
（1）若其左子树非空，则左子树上所有结点的值均小于根结点的值（关键字的值）；<br/>
（2）若其右子树非空，则右子树上所有结点的值均大于等于根结点的值；<br/>
（3）其左右子树本身又各是一棵二叉排序树。<br/>
左比根小，右比根大。<br/>
二叉排序树的常见操作<br/>
（1）Position FindMax(BiTree bt);从二叉搜索树bt中查找并返回最大元素所在结点的地址。<br/>
（2）BiTree Inssert(TElemType X,BiTree bt)<br/>
（3）BiTree Delete(TElemType X,BiTree bt)<br/>
判定树的条件：<br/>
（1）左子树中所有结点的值比根结点的值小<br/>
（2）右子树中所有结点的值比根结点的值大<br/>
折半查找的判定树一定是二叉排序树，反之则不一定<br/>
 二叉排序树的操作—查找<br/>
从与根结点的比较开始<br/>
若查找的关键字等于根结点，则成功；<br/>
否则若小于根结点，查其左子树；若大于根结点，查其右子树。在左右子树上的操作类似<br/>
二叉链表的定义<br/>
      <img src ="Images/look14.jpg" /> </br>
<br/>
 二叉排序树的查找算法设计<br/><br/>
  <img src ="Images/look15.jpg" /> </br>
 将“尾递归”函数改为迭代函数<br/>
  <img src ="Images/look16.jpg" /> </br>
查找最小者的算法<br/>
  <img src ="Images/look17.jpg" /> </br>
 查找最大者的算法<br/>
 <img src ="Images/look18.jpg" /> </br>
 二叉排序树的操作—插入<br/>
若二叉排序树为空，则插入结点应为根结点，否则，继续在其左、右子树上查找。<br/>
树中已有，不在插入；树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子。<br/>
一棵二叉排序树要保证仍然是一棵二叉排序树<br/>
二叉排序树的操作—生成<br/>
 <img src ="Images/look19.jpg" /> </br>
  <img src ="Images/look20.jpg" /> </br>
   <img src ="Images/look21.jpg" /> </br>
八、 二叉排序树的删除操作<br/>
三种情况<br/>
（1）如果删除的是叶结点：直接删除，再修改其父结点指针，置为NULL<br/>
（2）要删除的结点只有一个结点：将其父节点的指针指向要删除结点的孩子结点<br/>
（3）要删除的结点有左、右两棵子树：用另一个结点替代被删除结点；左子树的最大元素或者右子树的最小元素<br/>
要删除的节点有左右子树：要删除的结点左子树的最大值没有右儿子，被删除的结点右子树的最小值没有左儿子。<br/>
 二叉排序树的删除操作<br/>
<img src ="Images/look22.jpg" /> </br>
 创建一棵平衡二叉树<br/>
（1）插入新结点的时候，按照二叉排序树来进行处理；<br/>
（2）若插入的结点破坏了平衡二叉树的特性，就需要对平衡二叉树进行调整。<br/>
平衡二叉树的方法：<br/>
找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡子树，可将重新平衡的范围局限于这棵子树。<br/>
RR平衡旋转<br/>
若在A的右子树的右子树上插入结点，使A的平衡因子从-1增加至-2，需要进行一次逆时针旋转。（以B为旋转轴）<br/>
 LL平衡旋转<br/>
若在A的左子树的左子树上插入结点，使A的平衡因子从1增加至2，需要进行一次顺时针旋转（以B为旋转轴）<br/>
 LR平衡旋转<br/>
若在A的左子树的右子树上插入结点，使A得平衡因子从1增加至2，需要先进行逆时针旋转，再顺时针旋转。（以插入的结点C为旋转轴）<br/>
 RL平衡旋转<br/>
若在A的右子树的左子树上插入结点，使A的平衡因子从-1增加至-2，需要先进行顺时针旋转，再逆时针旋转。（以插入的结点C为旋转轴）<br/>
九、 哈希表的定义<br/>
 顺序查找、折半查找、二叉排序树查找的共同特点<br/>
（1）需要经过一系列的比较来确定关键字key的记录在表中的“地址”<br/>
（2）平均查找长度都不为0<br/>
（3）不同查找办法仅在于关键字和给定值进行比较的顺序不同<br/>
对于频繁使用的查找表，希望其ASL=0；解决方法为：预先知道所查找关键字在查找表中的位置。要求：记录在查找表中的位置和其关键字之间存在一种确定的关系。<br/>
 一般查找表存在的问题<br/>
（1）表长不确定<br/>
（2）在设计查找表时，只知道关键字所属的范围，而不知道确切的关键字值。<br/>
以H（key）作为关键字为key的记录在表中的位置，通常称这个函数H为哈希函数。<br/>
 哈希函数的基本思想<br/>
<img src ="Images/look23.jpg" /> </br>
（1）哈希函数是一个映象，它的设置很灵活；<br/>
（2）产生“冲突”现象，即：key1key2，而H（key1）=H（key2）<br/>
（3）很难找到一个不产生冲突的哈希函数<br/>
哈希表<br/>
根据设定的哈希函数H和所选中的处理冲突的方法，将一组关键字映象到一个有限的、地址连续的地址集（区间）上，并以关键字在地址集中的“象”H（key）<br/>
作为相应记录在表中的存储位置，如此构造所得的查找表，称之为“哈希表”。<br/>
 哈希函数的构造<br/>
考虑因素：地址空间尽量小；均匀<br/>
 构造方法<br/>
（1）直接定址法<br/>
H(key)=a*key+b(a、b为常数)<br/>
优点：以关键码key的某个线性函数值为哈希地址，不会产生冲突。<br/>
缺点：要占用连续地址空间，空间效率低。<br/>
（2）除留余数法<br/>
H(key)=key mod p（p是一个整数）<br/>
技巧：假设表长为，通常我们会选取pm且为质数<br/>
在构造哈希函数时考虑的因素：<br/>
1. 哈希表的大小；<br/>
2. 关键字的长度；<br/>
3. 执行速度（即计算哈希函数所需时间）<br/>
4. 关键字的分布情况<br/>
5. 查找频率<br/>
处理冲突的方法<br/>
开放定址法；链地址法<br/>
（1）开放定址法（开地址法）<br/>
基本思想：当有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希表地址总能找到，并将数据元素存入。<br/>
，i=1,2,…,k(k)<br/>
其中：H——哈希函数；m——哈希表长；——冲突地址序列；——增量序列<br/>
根据取值的不同，可以分为以下三种探测的方法：线性探测法;二次探测法；伪随机探测法<br/>
1. 线性探测法<br/>
，（1）<br/>
其中：m为哈希表长度，为增量序列1,2,…,m-1,且=i<br/>
2. 二次探测法<br/>
二次探测法处理冲突的方法如下：<br/>
其中：m为哈希表长度；为增量序列，，，，…,<br/>
三种处理冲突的方法的优缺点：<br/>
线性探测法：<br/>
优点：只要哈希表未被填满，保证能找到一个空地址单元存放有冲突的元素。<br/>
缺点：会产生“二次聚集”现象<br/>
二次探测法和伪随机探测法:<br/>
优点：可以避免“二次聚集”现象<br/>
缺点：不能保证一定能找到不发生冲突的地址<br/>
（2）链地址法（拉链法）<br/>
基本思想：将具有相同哈希地址的记录存储在同一个单链表中，m个哈希地址就对应m个单链表，然后用一个一维数组将m个单链表的表头指针存储起来，<br/>
形成一个动态的结构。<br/>
优点：非同义词不会冲突，无“聚集”现象：链表上结点空间动态申请，更适合于表长不确定的情况。<br/>



<table>
</table><%@ include file="copyright.jsp"%></td>
  </tr>
</table>
</body>
</html>
