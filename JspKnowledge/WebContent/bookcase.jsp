<%@ page contentType="text/html; charset=utf-8" language="java" import="java.sql.*" errorPage="" %>
<%@ page import="com.dao.BookCaseDAO" %>
<%@ page import="com.actionForm.BookCaseForm" %>
<%@ page import="java.util.*"%>
<html>
<%
Collection coll=(Collection)request.getAttribute("bookcase");
%>
<head>
<title>知识点系统</title>
<link href="CSS/style.css" rel="stylesheet">
</head>
<body onLoad="clockon(bgclock)">
<%@include file="banner.jsp"%>
<%@include file="navigation.jsp"%>
<table width="778"  border="0" cellspacing="0" cellpadding="0" align="center">
  <tr>
    <td valign="top" bgcolor="#FFFFFF"><table width="99%" height="510"  border="0" align="center" cellpadding="0" cellspacing="0" bgcolor="#FFFFFF" class="tableBorder_gray">


一、什么是最小生成树？<br/>


最小生成树是一副连通加权无向图中一棵权值最小的生成树。<br/>

如图所示。<br/>

 <img src ="Images/tree.jpg" /> </br>


它在实际中有什么应用呢？比如说有N个城市需要建立互联的通信网路，如何使得需要铺设的通信电缆的总长度最小呢？这就需要用到最小生成树的思想了。<br/>

二、Prim算法和Kruskal算法的原理<br/>

Prim算法原理：<br/>

1）以某一个点开始，寻找当前该点可以访问的所有的边；<br/>
2）在已经寻找的边中发现最小边，这个边必须有一个点还没有访问过，将还没有访问的点加入我们的集合，记录添加的边；<br/>
3）寻找当前集合可以访问的所有边，重复2的过程，直到没有新的点可以加入；<br/>
4）此时由所有边构成的树即为最小生成树。<br/>


Kruskal算法原理：<br/>

现在我们假设一个图有m个节点，n条边。首先，我们需要把m个节点看成m个独立的生成树，并且把n条边按照从小到大的数据进行排列。在n条边中，我们依次取出其中的每一条边，<br/>
如果发现边的两个节点分别位于两棵树上，那么把两棵树合并成为一颗树；如果树的两个节点位于同一棵树上，那么忽略这条边，继续运行。等到所有的边都遍历结束之后，如果<br/>
所有的生成树可以合并成一条生成树，那么它就是我们需要寻找的最小生成树，反之则没有最小生成树。<br/>

总的来说，Prim算法是以点为对象，挑选与点相连的最短边来构成最小生成树。而Kruskal算法是以边为对象，不断地加入新的不构成环路的最短边来构成最小生成树。<br/>
克鲁斯卡尔最小生成树算法（Kruskal算法）<br/>
1.基本思想<br/>
1.  把图中的顶点看成n个不同的顶点集，每个顶点集都只含有1个顶点；<br/>
2.  每次都在横跨不同顶点集的边中选择一条权值最小的边加入到最小生成树中；<br/>
3.  直到图中所有的顶点都在同一个顶点集中为止<br/>
注意：<br/>
1.每次在进行边的选择时，是否是在所有的边中将已选择的边去掉之后，在剩下的边中选择权值最小的边<br/>
2.候选边一定要求边的两个端点分别属于两个不同的顶点集中<br/>
3.求解思路<br/>
1.连通图的边按照权值从小到大进行排列；<br/>
2.依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中，不是，则不加入生成树中<br/>


拓扑排序<br/>
介绍<br/>
1. 有向无环图：一个无环的有向图；<br/>
2. 作用是描述一项工程或系统的进行过程<br/>
3. AOV网：顶点表示活动，用有向边表示活动之间的优先关键的有向图<br/>
（1）不允许出现环，这意味着某项活动应以自己为先决条件。<br/>
（2）若<Vi，Vj>是图中有向边，则Vi是Vj的直接前驱，Vj是Vi的直接后继<br/>
4. 拓扑排序：将AOV网中所有的顶点按照他们之间的相互关系的优先顺序排成一个线性序列的过程。<br/>
5. 拓扑序列：拓扑排列所得到的序列<br/>
 拓扑排序的方法<br/>
1. 在有向图中选一个没以前驱的顶点且输出；<br/>
2. 从图中删除该顶点和所有以它为尾的弧；<br/>
3. 重复上述两步，直到全部顶点均已经输出；或者当图中不存在无前驱的结点为止。<br/>
图的最短路径问题<br/>
图的最短途径<br/>
地图导航、城市交通图、站点之间最短路径等，这些问题都可以使用带权图描述如下：<br/>
（1）源点：第一个顶点；<br/>
（2）终点：最后一个顶点；<br/>
（3）权值：所花的费用或时间等<br/>
（4）最短路径：源点与终点之间权值最小的路径<br/>
图的最短路径问题分类<br/>
（1）单源最短路径问题<br/>
从某个固定的源点出发，求这个源点到其他所有项点的最短距离。<br/>
（2）多源最短路径问题<br/>
求任意两个顶点之间的最短距离。<br/>
 Dijkstra算法<br/>
按照路径长度递增（非递减）的顺序产生最短路径。迪杰斯特拉算法适用于有向图和无向图。<br/>
Dijkstra算法具体过程<br/>
1. dist[1] V0到此顶点的最小路径长度；<br/>
2. dist[2] dist[3] dist[4] dist[5] dist[6]只能以S中的顶点作为中转而形成的路径中长度最短的路径长度<br/>
注意：保持从V0 到集合S中各顶点的最短路径长度都不可大于从V0到集合V-S中的任何顶点的最短路径长度。<br/>
3.3.2 初始化顶点<br/>
for(i=1;i++)<br/>
   visited[i]=0;<br/>
visited[V0]=1;//V0为源点<br/>
3.3.3 prev数组的初始化<br/>
for(i=1;i<=n;i++)<br/>
   {  dist[i]=G.A[V0][i];<br/>
      if(dist[i]=9999)<br/>
           prev[i]=-1；<br/>
      else<br/>
           prev[i]=0;<br/>
}<br/>
dist[V0]=0;<br/>

3.3.4 完整算法描述<br/><br/>
 <img src ="Images/tree1.jpg" /> </br>

 多源最短路径问题<br/>
方法1：把单元最短路径算法调用v次，但是对于稠密图来讲效率不高<br/>
方法2：Floyd算法<br/>
特点：每一条最短路径不是一次确定，而是逐步形成，适用于用邻接矩阵存储的稠密图的多源路径最短问题<br/>
Floyd算法基本思想<br/>
通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。<br/>
矩阵P中的元素b[i][j]，表示顶点i到顶点j经过了b[i][j]记录的值所表示的顶点。<br/>
假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞，<br/>
矩阵P的值为顶点b[i][j]的j的值。 接下来开始，对矩阵D进行N次更新。第1次更新时，如果”a[i][j]的距离” > “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j<br/>
之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”,更新b[i][j]=b[i][0]。同理，第k次更新时，如果”a[i][j]的距离” > “a[i][k-1]+a[k-1][j]”，
则更新a[i][j]为”a[i][k-1]+a[k-1][j]”,b[i][j]=b[i][k-1]。更新N次之后，操作完成！<br/>
Floyd完整算法<br/>
 <img src ="Images/tree2.jpg" /> </br>
 <table>
</table><%@ include file="copyright.jsp"%>

</td>
  </tr>
</table>
</body>
</html>
